
# java 并发知识梳理 #

- synchronized 关键字
- volatile 关键字
- ThreadLocal
- 线程池
- Atomic 原子类
- AQS

## synchronized 关键字 ##

- 对synchronized关键字的了解
- 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗
- synchronized 关键字的底层原理
- JDK1.6 之后的synchronized 关键字底层做了哪些优化
- 谈谈 synchronized和ReentrantLock 的区别

### 对synchronized关键字的了解  ###

- synchronized主要解决多线程之间访问资源的同步性，可以保证被该关键字修饰的方法，代码块在任意时刻只能被一个线程访问。
- 在早期的版本里，synchronized属于重量级锁，效率低下。因为监视器锁(monitor)是依赖底层操作系统Metux lock(互斥锁)来实现的，java的线程都要映射到系统原生线程上去，线程的挂起和唤醒都需要操作系统帮忙完成。而操作系统实现线程转换需要由用户态转到内核态，这个转换比较耗时。
- 在jdk1.6之后，synchronized有比较大的优化。使用了如：自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少开销。


### 说说自己是怎么使用 synchronized ###
	synchronized的使用有三种方式
- 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前获取当前对象实例的锁。
- 修饰静态方法: 也是给当前类加锁
- 修饰代码块：指定加锁对象, 不要用字符串常量来加锁，因为字符串常量具有缓冲池功能。

### synchronized 关键字的底层原理 ###

### JDK1.6 之后的synchronized 关键字底层做了哪些优化 ###

- 锁存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
- 引入偏向锁、轻量级锁的目的一样，都是为了在没有多线程竞争的情况下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。
- 偏向锁，在无竞争情况下，完全把整个同步消除掉，轻量级锁，在无竞争下回使用CAS操作代替互斥量。

#### 偏向锁 ####

	偏的意思是，会偏向第一个获得他的线程，对于竞争激烈的锁，偏向锁就失效了。偏向锁失败后会升级为轻量级锁。
	
#### 轻量级锁 ####
	 
	 轻量级锁，在大部分操作的时间里是没有线程去竞争的，因为时间都比较短，不需要去申请重量级锁，轻量级锁使用了CAS机制
#### 自旋锁 ####	 
	轻量级锁失败后，会采用自旋锁去避免使用互斥。因为互斥对性能的影响是阻塞的实现，因为挂起线程和恢复线程都需要操作系统内核完成，从用户态转到内核态比较耗时。
	一般线程拥有锁的时间都不会很长，仅为了这一点时间去挂起线程不值得。所以可以让后面来请求的线程等待一会，默认自旋的次数是10次。
	自适应自旋锁自旋的次数时间不一样了，由JVM自行决定。
	
#### 锁消除 ####	 	
	
	JVM在编译或运行的时候检测到某些共享数据不可能存在竞争，就自行去除了。
	
### synchronized和ReentrantLock 的区别 ###	

- 两者都是可重入锁，就是一个线程获取了某个对象的锁，还未释放，该线程可再次获取。
- ReentrantLock 增加了一些高级功能：
	等待中断（lock.lockInterruptibly()）
	可以指定是否公平，非公平锁，默认是非公平的，synchronized是非公平的。
	实现选择性通知，绑定多个condition条件。

## ThreadLocal ##

- 保存每个本地副本

## 线程池 ##

- 实现Runnable接口和Callable接口的区别
- 执行execute()方法和submit()方法的区别是什么呢

### 执行execute()方法和submit()方法的区别是什么呢 ###

- execute()方法用于提交不需要返回值的任务
- submit()可以返回一个Future对象，该对象get（）方法可以获取线程运行结果

## Atomic 原子类 ##

- 原理：原子类主要利用CAS机制。原理是拿期望值和原本值比较，若相同，则更新为新的值。

	


