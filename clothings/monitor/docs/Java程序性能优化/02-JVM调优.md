
# 02-JVM调优

- JVM内存模型结构
- 与内存分配(尤其是堆分配)相关的JVM参数
- 垃圾回收器的种类以及使用方法
- 一些常用的JVM调优参数及其使用效果
- JVM实用参数

## JVM内存模型结构

为了使使java程序能够运行在JVM上，虚拟机将其内存数据分为几个部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区等部分。

### 程序计数器

程序计数器是一块很小的内存空间，由于java是支持线程的语言，当线程数超过CPU核心数时，线程根据时间轮片抢夺CPU资源，对于每一个CPU而言，每一时刻，只能有一个线程在运行，而其他线程
必须被切换出去。
因此每个线程都必须拥有一个独立的程序计数器，用于记录下一条运行的指令。

如果当前线程正在执行一个java方法，则程序计数器记录正在执行java字节码的地址。
如果正在执行一个native方法，则程序计数器为空。

### 虚拟机栈

java虚拟机栈也是线程私有的内存空间，和java线程在同一时间创建，它保存方法的局部变量，部分结果，并参与方法的调用和返回。

java虚拟机规范允许java栈的大小是动态或固定的。在虚拟机规范中，定义了两种异常与栈空间有关：StackOverflowError和OutOfMemoryError。如果在线程计算中，请求栈的深度
大于最大可用深度，则抛出StackOverflowError；若栈是可以动态扩展的，在扩展过程中没有足够的空间，则抛出OutOfMemoryError。

在Hot spot虚拟机中，可以使用-Xss参数来设置栈的大小，栈大小直接决定函数调用的可达深度。

### 本地方法栈

本地方法栈和虚拟机栈很相似，只不过本地方法栈是管理本地方法调用的，同样也会抛出StackOverflowError和OutOfMemoryError。

### 堆

java堆是java内存中最重要的部分，几乎所有对象和数组都是在堆中分配空间的。
java堆分为新生代和老年代，新生代用于存放刚刚产生的对象和年轻的对象，如果对象一直没被回收，生存的足够长，对象就会被移入老年代。

新生代又可以进一步细分为：eden、s0(from space)、s1(to space)。

### 方法区

方法区也是线程共享的，1.8之后称为元空间。

## JVM内存分配参数

JVM内存分配对java应用程序性能有较大的影响。接下来主要介绍java应用程序内存大小和结构的设置方法。如设置堆大小、新生代大小、元空间或持久代大小、线程栈大小等。

### 设置最大堆内存

可以用-Xmx设置最大堆内存。该参数也可指定到某个类。

### 设置最小堆内存

使用-Xms设置最小堆内存。也就是JVM启动占据操作系统内存大小。

JVM会试图将内存使用尽可能限制在-Xms中，因此当实际使用内存达到-Xms指定值时，会触发 Full GC. 因此把-Xms和-Xmx设置为一致时，可以减少初期GC频率和耗时。


## 垃圾收集器

java语言的一大特性就是可以自动进行垃圾回收，本节主要讲解一下垃圾收集器的算法、种类、以及使用方法。

### 垃圾收集器算法与思想

#### 引用计数法

- 引用计数法：就是某个对象当其引用为0时，就是可以清除的。

#### 标记清除法

标记清除法：是现代垃圾回收思想，将回收分为：标记和清除两个阶段。


- 标记阶段：标记所有通过根节点可达的对象，未被标记的对象就是未被引用的对象，即要清除的对象。该方法最大的问题是回收后存在很多的内存碎片。

####  复制算法

- 复制算法：与标记算法相比，复制算法是比较高效的垃圾回收算法，核心思想是：把内存空间分为两部分，每次只使用其中一块，垃圾回收时将不被回收的对象移至未使用的内存区，然后把另外
一块已使用的全部清除。复制算法要求要复制存活的对象并不会太大。
在复制的时候如果对象比较大或年代比较久，就会移入老年代。复制算法比较适用新生代，因为新生代的垃圾对象会远多于存活对象。

#### 标记压缩法

- 复制算法对如果一次性能回收比较多的对象，效率还是高的，但对于老年代，经过GC后存活对象仍很多的内存区来说并不好，此时可以采用标记压缩法。
- 核心思想：对存活的对象进行标记，并压缩至区域一端，将另一端全部清除，这样就减少了内存碎片的问题。


### 垃圾收集器类型

按线程数分类

- 串行垃圾回收器：一次只使用一个线程回收。
- 并行垃圾回收器：开启多个线程执行回收，在能力较强的CPU上，使用并行收集器可以减少GC停顿时间。

按工作模式分类

- 并发模式垃圾回收器：并发模式回收器可以与应用线程交替工作，减少应用程序停顿时间。
- 独占式垃圾回收器：独占式也称Stop the world， 停止应用程序所有其他线程，直到垃圾回收结束。

按碎片处理方式

- 压缩式：是在回收完之后，对存活对象进行压缩整理，然后消除回收后的碎片。
- 非压缩式：就是不进行压缩整理，不回收碎片。

按工作的内存区域

- 新生代垃圾处理：
- 老年代垃圾处理：

### 评论GC策略的指标

- 吞吐量：就是GC总耗时越小，吞吐量越大。
- 停顿时间：就是由于GC导致程序的暂停时间。串行垃圾收集器比并行的停顿时间长，但效率（即回收更多的空间，更快）会更高，所以串行可能总的吞吐量会更大。
- 垃圾回收频率：

### 市场上垃圾回收器介绍

#### 新生代串行回收器

- 串行收集器是所有垃圾器中最老的一个，使用单线程和独占式进行垃圾回收，效率较高。
- 适用单CPU或内存较小的硬件平台。
- 在Hot Spot 虚拟机中，使用-XX:+UseSerialGC，可以指定使用该收集器。

#### 老年代串行收集器

- 老年代串行垃圾回收器使用标记压缩法，和新生代串行回收器一样，也是一个串行独占式回收器。
- 老年代通常回收时间会比较长，在堆空间较大的应用中，一旦老年代串行垃圾收集器开始启动，应用程序可能会停顿几秒或更长。
- 若要启用老年代垃圾回收器，可以尝试使用以下参数：
	* -XX:+UseSerialGC: 新生代、老年代都启用串行回收器；
	* -XX:+UseParNewGC: 新生代使用并行收集器，老年代使用串行。
	* -XX:+UseParallelNewGC: 新生代使用并行收集器，老年代使用串行。
	
#### 并行收集器

并行回收器是工作在新生代的垃圾收集器，它只是将串行收集器多线程化，其他算法都一样。并行收集器也是独占式收集器。
可以用以下参数开启：

- -XX:+UseParNewGC 新生代用并行收集器，老年代用串行收集器。
- -XX:+UseConcMarkSweepGC 新生代用并行收集器，老年代用CMS	

#### 新生代并行回收收集器（Parallel Scavenge）

该收集器也是使用复制算法进行回收，从表面上看他也是和并行收集器一样多线程独占式。但他更关注系统的吞吐量。可以使用两个参数来控制吞吐量。

- -XX:+UseParallelGC 新生代使用并行回收收集器，老年代使用串行收集器
- -XX:+UseParallelOldGC 新生代和老年代都使用该收集器

- -XX:MaxGCPauseMillis： 最大停顿时间

#### 老年代并行回收收集器

#### CMS收集器

与并行回收收集器不同的是，CMS收集器更关心停顿时间。CMS是Concurrent Mark Sweep的缩写，意思为并发-标记-清除。
CMS在部分工作流程中可以与应用线程同步工作，从而降低应用程序停顿时间。


## JVM实用参数

JVM提供了不少与改善系统或故障排查相关的参数，下面将分别介绍。

- JIT编译参数：将字节码编译成本地代码，提高函数的执行效率。

### 堆快照

在性能问题排查中，分析堆快照文件是必不可少的一环。

- -XX:+HeapDumpOnOutOfMemoryError参数，在发送OOM时导出当前应用程序堆快照。
- -XX:HeapDumpPath: 指定堆快照保存的位置。
- 可以使用Visual VM工具分析堆快照。

### 获取GC信息

若获取简短的GC信息，比如GC前后堆的大小的变化，及GC的耗时可以使用-XX:+PrintGC.

若想要获取详细信息：可以使用-XX:+PrintGCDetails，该参数可以输出GC时年轻代、年老代、各区的内存使用情况。

-XX:+PrintGCTimeStamps 可以打印GC的时间戳。
-XLoggc: 指定GC信息输出目录












