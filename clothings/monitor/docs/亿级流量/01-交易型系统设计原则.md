
# 01-交易型系统设计原则

## 1. 大流量缓冲

在电商搞大促时，系统流量会高于正常几倍甚至几十倍，此时系统需要一些特殊的设计来保证系统平缓的度过这段时期。解决的手段一般都是牺牲强一致性，而保证最终一致性即可。

比如，**扣减库存**，可以考虑如下设计：

redis扣减库存  --> 记录扣减日志  --> 同步Worker  --> 库存DB

直接在redis里扣减库存，然后记录下扣减日志，通过Worker同步到库存DB。


还有，如**交易订单系统**，可以考虑这样设计：

1 结算服务 --> 2 接单服务 --> 3.1 订单redis/ 3.2 订单队列表 

流程说明：

- 1. 首先，结算服务调用订单接单服务，将订单存储到订单 Redis 和订单队列表，订单队列表可以按照需求水平扩展为多个表，通过订单队列表提升接单能力。
- 2. 然后通过同步 Worker 同步到订单中心表。
- 3. 假如用户支付了订单，订单状态机会驱动订单状态改变，此时可能订单队列表的订单还没有同步到订单中心表，状态机要根据实际情况重试。
- 4. 如果用户查看单个订单详情，那么可以直接从Redis查看，但如果查询订单列表，则需考虑将订单Redis 和列表的合并。
- 5. 同步Worker在设计时，需要考虑并发处理和重复处理的问题，比如使用单机串行处理（每台Worker只扫描其中一部分表），还是集群处理（Map Reduce）。另外，需要考虑对订单队列表添加相关字段：处理人（哪个应用正在处理）、处理状态（正在处理、已处理、处理失败）、最后处理时间（应对超时）、失败次数等。

## 2. 数据校对

在使用了消息异步机制的场景下，可能存在消息丢失，需要考虑进行数据校对和修正，来保证数据的一致性和完整性。通过 Worker 定期去扫描原始表，通过对业务数据进行校对，有问题的药进行补偿，扫描周期根据实际场景进行定义。

## 3 数据异构

**1. 数据异构**

订单分库分表一般按照订单ID进行，但如果要查询某个用户的订单列表，则需要聚合多个表的数据才能返回，这样会导致订单表的读性能很低。此时需要对订单表异构，异构一套用户订单表，按照用户ID进行分库分表。另外还需考虑对历史订单数据进行归档处理。

**2. 数据闭环**

实现数据闭环，如商品详情页，数据来源太多，影响服务稳定性因素也就越多。因此最好的办法把使用到的数据进行异构存储，形成闭环，基本步骤如下：

- 数据异构：通过如MQ机制接收数据变更，然后原子化存储到合适的存储引擎中，如 Redis 或持久化KV存储。
- 数据聚合：这一步是可选的，数据异构的目的是把数据从多个数据源拿过来，数据聚合的目的是把这些数据聚合，这样前端一个调用可以拿到所有数据，此步骤一般存储到KV存储中。
- 前端展示：前端通过一次货少量几次调用拿到所需数据。

这种做法好处是数据闭环，任何依赖系统出了问题，还是能正常工作，只是更新会有积压，但不影响前端展示。

## 4 缓存银弹

缓存对于读服务来说可谓抗流量的银弹，可总结为如下表：

- 客户端
	* 使用浏览器缓存
	* 客户端应用缓存
- 客户端网络
	* 代理服务器开启缓存
- 广域网
	* 使用代理服务器
	* 使用镜像服务器
	* 使用P2P技术
- 源站及源站网络
	* 使用接入层提供的缓存机制
	* 使用应用层提供的缓存机制
	* 使用分布式缓存
	* 静态化、伪静态化
	* 使用服务器操作系统提供的缓存机制

**1. 浏览器缓存**

设置请求的过期时间，如对响应头Expires、Cache-control进行控制，这种机制使用于对实时性不太敏感的数据，如商品详情页框架、商家评分、评价、广告词等；但对于库存、价格等实时性较高的数据，不能做浏览器缓存。

**2. APP 客户端缓存**

在大促时为了防止瞬间流量冲击，一般会在大促之前把APP需要访问的一些素材（如js/css/img）提前下发到客户端进行缓存，另外首屏数据页可以缓存起来。

**3. CDN缓存**

有些页面、活动页、图片等服务可以考虑将页面推送到离用户近的CDN节点。

**4. 接入层缓存**


## 5. 高可用原则

### 5.1 降级

对于高可用服务，很重要的一个设计就是降级开关，在设计降级开关时，主要依据如下思路：

**1. 开关集中化管理**

通过推送机制把开关推送到各个应用。

**2. 可降级的多级读服务**

比如：服务调用降级为只读本地缓存、只读分布式缓存、只读默认降级数据。

**3. 开关前置化**

如架构是 Nginx --> Tomcat ，可以将开关前置到 Nginx 接入层。

**4. 业务降级**

当高并发流量来袭时，只保证核心需求被调用，其他可以同步改异步等。

dubbo中的服务降级：向要被降级的服务接口配置mock值；

- mock=force:return+null, 表示不发起远程调用，直接返回null。
- mock=fail:return+null,表示对该服务调用失败时返回null。

### 5.2 限流

限流的目的是防止恶意请求流量、恶意攻击，或者流量超出系统峰值。可以考虑如下思路：

- 1. 恶意请求流量只访问到cache
- 2. 对于穿透到后端应用的流量，可以考虑使用nginx的limit模块处理
- 3. 对于恶意IP可以使用nginx deny进行屏蔽。

### 5.2.1 nginx 限流配置

**1. 限流算法**

令牌桶算法：

- 令牌亿固定速率产生，并缓存到令牌桶中。
- 令牌桶放满时，多于的令牌直接丢弃
- 请求要消耗等比例的令牌，才能被处理
- 令牌不够时，请求被缓存

漏桶算法：

- 1. 水(请求)从上方导入水桶中，从水桶下方流出(被处理)
- 2. 来不及流出的水存在水存在水桶中，以固定速率流出。
- 3. 水桶慢后水会溢出

该算法的核心思想是缓存请求，匀速处理，多于的请求直接丢弃。

nginx按请求速率限速算法是漏桶算法，即多于的请求会丢弃。

nginx官方限制IP的连接和并发分别有两个模块：

- limit\_req\_zone: 用来限制单位时间内的请求数，即速率限制。
- limit\_req\_conn: 用来限制同一时间连接数，即并发限制。






